##Лабораторна робота №4

##У цій роботі я навчився використовувати патерн "Стратегія".

Я створив інтерфейс ISortStrategy ("контракт" на сортування) і дві його реалізації: для сортування вгору (AscendingSortStrategy) та вниз (DescendingSortStrategy).
Це дозволило легко міняти логіку сортування в основній програмі, просто "підсовуючи" їй потрібну стратегію. Також я відокремив обчислення (мін/макс/середнє) в окремий клас ArrayCalculator, щоб не змішувати все до купи.
Тепер я розумію, як інтерфейси допомагають писати гнучкий код, де поведінку можна змінювати "на льоту".

---

## У чому різниця між абстрактним класом і інтерфейсом?

Інтерфейс – це 100% "голий" контракт. Це список того, що клас мусить робити, але жодного рядка як це робити. Клас може "підписати" (реалізувати) багато таких контрактів.
Абстрактний клас – це "напівфабрикат". Він може мати і готові методи (з кодом), і абстрактні (без коду). Він ніби каже: "Ось це я вже зробив за тебе, а ось це – допиши сам". Клас може успадкувати тільки один такий.

---

## Коли краще використовувати композицію, а коли наслідування?

Наслідування (це "є"): Використовуй, коли один об'єкт дійсно є різновидом іншого. Наприклад, "Студент" є "Людина". Це жорсткий зв'язок.
Композиція (це "має"): Використовуй, коли один об'єкт має в собі інший. Наприклад, "Машина" має "Двигун".  Це набагато гнучкіше! Майже завжди краще вибирати композицію, якщо сумніваєшся.

---

## Як працює агрегація та чим вона відрізняється від композиції?

І те, і те – "має в собі" (has-a). Різниця лише в "міцності" зв'язку:
Композиція (сильна): Частина не може жити без цілого. Якщо знищити "Будинок", то його "Кімнати" теж зникнуть. Вони "склеєні" намертво.
Агрегація (слабка): Частина може жити окремо. "Університет" має "Студентів".  Якщо універ закриють, студенти не зникнуть, а просто підуть в інший.

---

## Чи може клас реалізовувати кілька інтерфейсів одночасно?

Так. Це одна з їхніх головних фішок. Клас може бути одночасно, наприклад, `ISortable` (вміти сортувати), `IPrintable` (вміти друкувати себе) і `ISaveable` (вміти зберігатись у файл). Це як людина, яка вміє і готувати, і на гітарі грати.

---

## Для чого в ООП використовують інтерфейси як контракти?

Якщо клас реалізує інтерфейс `ISortStrategy`, ми гарантовано знаємо, що у нього є метод `Sort()`. Нам байдуже, як він там всередині працює. Ми просто знаємо, що можемо викликати цей метод. Це дозволяє писати гнучкий код, який працює з будь-якими об'єктами, що "підписали" цей контракт.
